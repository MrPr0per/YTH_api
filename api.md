- общая информация для всех запросов:
	- про jwt токены
		- все jwt токены будут иметь одну структуру:
			- ```js
				{
					"ver": str, // (version)      версия токена (чтобы можно было потом расширять эту структуру)
					"iat": int, // (issued at)    время выдачи (в Unix Time)
					"exp": int, // (expired)      время истечения (в Unix Time)
					"jti": str, // (twt token id) id токена (чтобы можно было его отзывать через сохранение jti в блеклист, пока он не истечет)
					"roles": list[str], //        роли (для проверки доступов)
					"context": { //               доп поля, которые зависят от ролей
						...
					}
				}
			  ```
	- про роли и доступы
		- пользователь подтверждает свои роли через jwt токен
		- какие роли будут и какие у них будут доступы:
			- `<без роли, токен вообще не нужен и не проверяется>`
				- просмотр постов, евентов, курсов
				- вход в аккаунт
			- `with_confirmed_email` с `email:str` в контексте
				- регистрация
				- восстановление аккаунта
			- `logged_in` с `sub:str` в контексте
				- `sub` (subject) - id пользователя
				- просмотр, удаление, редактирование, выход из своего аккаунта
				- загрузка, изменение, удаление документов
				- смена пароля
					- %% В будущем можно дополнительно проверять доступ к почте перед сменой пароля через требование роли with_confirmed_email %%
			- `student` (является `logged_in_user`)
				- подача заявки на эксперта
				- запись и раз-запись на евенты и курсы
			- `admin` (является `logged_in_user`)
				- создание, редактирование, удаление постов (только своих)
					- %% (в будущем можно выделить это в отдельную роль редактора) %%
					- %% (так же на будущее можно добавить админу право выдавать и отзывать роли (кроме роли админ)) %%
				- создание, редактирование, удаление евентов (всех)
				- создание, редактирование, удаление курсов (всех)
				- принятие/отклонение заявок на эксперта
			- `superadmin` (является `admin`)
				- выдача и отзыв роли `admin`
		- как выдаются
			- Пользователи (student-ы) - получают свою роль при регистрации
			- Админов назначает суперадмин из пользователей
			- Суперадмина назначаем мы вручную
	- про access/refresh токены
		- при регистрации и входе будут создаваться 2 токена: access_token и refresh_token
		- про эту схему с двумя токенами:
			- https://habr.com/ru/companies/Voximplant/articles/323160/
		- но если кратко:
			- access токен короткоживущий, его нужно будет посылать с каждым запросом в заголовке Authorization
			- refresh - долгоживущий, хранится в HttpOnly+Secure куках (к нему нет доступа из js)
			- если access истечет, нужно сделать запрос на /refresh, чтобы обновить оба токена
			- если refresh истечет, нужно будет снова залогиниться по паролю
		- access токен - это jwt с выше описанной структурой
		- refresh токен - это просто случайная строка
		- время жизни у них:
			- у access - около 10 мин
			- у refresh - около 30 дней
		- Как передаются:
			- refresh автоматически кладется в `HttpOnly; Secure; SameSite=Strict cookie`
			- access передается в теле, его нужно хранить только в памяти (не класть в куки/хранилища) (для защиты от xss) и потом класть в Authorization заголовок
	- про ошибки
		- формат
			- в теле ответа 4xx (и ==возможно== 5xx) всегда будет как минимум 2 поля: код ошибки и сообщение для отладки (которое нельзя показывать пользователям в сыром виде): `{"error_code": "urn:error:tooManyRequests", "message": "..."}`
			- прописывать конкретные коды ошибок мы будем по мере разработки, заранее сказать какие могут возникать ошибки - тяжело
		- общие ошибки
			- для любых запросов:
				- 404
					- если указанного эндпоинта нет
				- 405 Method Not Allowed
					- если серверу метод известен, но указанный в запросе метод не поддерживаем для ресурса. Например, использование POST/PUT для ресурса, доступного только на чтение через GET
				- 429 Too Many Request
					- Штобы не флудили!
				- 500
					- при ошибках сервака
			- для любых запросов после входа (если не сказано обратного)
				- 401 Unauthorized
					- если access или refresh токен истек или вовсе не был предоставлен
			- для любых запросов с телом/query-параметрами/параметрами в пути
				- 400 Bad Request
					- Если параметры в неверном формате
				- 404
					- Если ресурса по какому то из переданных айдишников нет
				- 422 Unprocessable Entity
					- Если параметры корректны синтаксически, но некорректны семантически
			- для любых запросов с ограниченным доступом
				- 403 Forbidden
					- нет прав
	- про ответы:
		- все возможные ответы:
			- (не закомментированные будут прописаны явно в каждом случае, а закомментированные уже были описаны выше в "общие ошибки")
			- ```js
				2xx
				    200 Ok
				    201 Created
				    204 No Content
				4xx
				    // 400 Bad Request
				    // 401 Unauthorized
				    // 403 Forbidden
				    // 404 Not found
				    // 405 Method Not Allowed
				    409 Conflict
				    // 410 Gone
				    422 Unprocessable Entity
				    // 429 Too Many Reques
				5xx
				    // 500 Internal Server Error
			  ```
	- общие заголовки для любых запросов после входа (если не сказано обратного)
		- `Authorization: Bearer {access_token}`
	- серверные заголовки:
		- Strict-Transport-Security
			- Гарантирует, что браузер всегда использует HTTPS
		- Content-Security-Policy
			- Ограничивает, какие скрипты, стили, изображения можно загружать и выполнять
		- X-Frame-Options
			- Запрещает отображать твой сайт в чужом `iframe`
		- X-Content-Type-Options
			- защита от MIME-sniff атак
	- про пагинацию
		- у любого запроса списка ресурсов будет одинаковая пагинация:
		- ?cursor={before/after:{id}}&take={count}&orderBy={fieldName}:{asc/desc} (GET)
			- query параметры пагинации:
				- `cursor: (direction: str, id:Id)?`
					- какой блок значений брать
					- `?cursor=after:{id}` - будет брать `count` элементов ПОСЛЕ элемента с данным id НЕ включительно
					- `?cursor=before:{id}` - будет брать `count` элементов ПЕРЕД элементом с данным id НЕ включительно
					- по умолчанию берет первые `count` элементов
				- `take: int`
					- сколько элементов взять
				- `orderBy: {fieldName: str, order: str}?`
					- поле и направления сортировки
					- строки с одинаковым значением выбранного поля сортируются по id
					- по умолчанию сортирует только по id
					- Пример: `?orderby=name:asc`
		- также у любого такого запроса будут ответы одного формата
			- ответы:
				- 200
					- в теле объект типа PaginationPage (см "объекты/типы")
				- 404 - если id из from не существует
				- 400 - если заданы некорректные параметры, например
					- если take не указан
					- если take отрицательное
					- если у orderBy некорректный формат
					- если в orderBy указано несуществующее поле или поле, по которому невозможно сортироваться (например поле типа список)
	- ~~про ссылки на ресурсы~~ (тут лучше всегда смотреть индивидуально)
		- пример:
			- `Course`
				- ```js
					{
						"id": Id,
						// ...
						"tags": [Id(Tag)],
					}
				  ```
		- если один ресурс ссылается на другой через Id в своем содержании, то работа с ним будет выглядеть так:
		- create - на месте этих ресурсов - айдишники
		- read - будет дополнительный параметр
			- ?expand={isExpand: bool}
				- если True - заменяет id всех используемых ресурсов на объекты
				- по умолчанию True
			- Однако будет он только если ресурсы по ссылкам будут не большие и не будут содержать ссылок на другие ресурсы
				- в противном случае хз как лучше реализовать, нужно смотреть индивидуально
	- про JSONPATCH
		- https://jsonpatch.com/
		- далее, если в теле будет приниматься JSONPATCH, рядом будет указано к какому объекту он будет применяться

- шаблон:
	- ендпоинт (метод) - описание
		- доступ:
			- для кого доступен этот метод
		- эффекты (если есть)
			- что делает этот эндпоинт, кроме взаимодействия с ресурсом в бд
		- тело запроса (если есть)
			- ...
		- query параметры (если есть)
			- ...
		- ответы:
			- код - описание
				- заголовки (если есть)
					- ...
				- тело (если есть)
					- ...
			- ...

- объекты/типы
	- `Id`
		- у нас id - это uuid строка
		- `Id(T)` означает, что это id ресурса T
	- `IsoDateTime`
		- строка с датой и временем в формате iso
	- `PaginationPage<T>`
		- ```js
			{
				"total": int,  // общее число элементов (потенциально может
								// измениться по мере обхода списка ресурсов)
				"actualTake": int, // сколько реально удалось получить
				"items": [T], // T - тип запрашиваемого ресурса
			}
			```
	- `Activity`
		- одно из
			- Cource
			- Event
	- `PostStatus`
		- одно из
			- Posted
			- Hidden
	- `ExpertApplicationStatus`
		- одно из
			- Created
			- Sent
			- AcceptedForReview
			- Reviewed
	- `ExpertApplicationActionType`
		- возможные экшоны и их доп.поля (т.е. `action: other`):
			- ```js
				"Created": null
				"Sent": null
				"CanceledSending": null
				"Accepted": {
					AcceptedBy: Id(User),
					message: str,
				}
				"СanceledAcceptance": null
				"Reviewed": {
					isApproved: Bool,
					resolutionMessage: str?, // если принято, то сообщение писать незачем, оно должно быть null
				}
				"СanceledReview": null
			  ```
	- `EventType`
		- одно из
			- Offline
			- Online
	- `UserRole`
		- одно из
		    - Student
		    - Expert
		    - Admin
		    - SuperAdmin

- ресурсы
	- `User`
		- ```js
			{
				"id": Id, // управляется сервером
				"username": str,
				"role": UserRole // управляется сервером, по умолчанию Student
			}
		  ```
	- `Course`
		- ```js
			{
				"id": Id, // управляется сервером
				"сreatedAt": IsoDateTime, // управляется сервером
				"name": str,
				"description": str,
				"link": str,
				// "category": Id(Category),
				// "tags": [Id(Tag)],
			}
		  ```
	- `Event`
		- ```js
			{
				"id": Id, // управляется сервером
				"сreatedAt": IsoDateTime, // управляется сервером
				"name": str,
				"description": str,
				"date": IsoDateTime,
				"adress": str?,
				"type": EventType,
			}
		  ```
	- `Category`
		- ```js
			{
				"id": Id, // управляется сервером
				"name": str
			}
		  ```
	- `Tag`
		- ```js
			{
				"id": Id, // управляется сервером
				"name": str
			}
		  ```
	- `EventRegistration`
		- регистрация на евент
		- ```js
			{
				"id": Id, // управляется сервером
				"сreatedAt": IsoDateTime, // управляется сервером
				"user": Id(User),
				"event": Id(Event)
			}
		  ```
	- `CourseRegistration`
		- регистрация на курс
		- ```js
			{
				"id": Id, // управляется сервером
				"сreatedAt": IsoDateTime, // управляется сервером
				"user": Id(User),
				"course": Id(Course)
			}
		  ```
	- `Post`
		- ```js
			{
				id: Id, // управляется сервером
				сreatedAt: IsoDateTime, // управляется сервером
				author: Id(User), // управляется сервером
			    // category: Id(Category),
			    title: str,
			    // shortDescription: str,
			    description: str,
			    status: PostStatus, // по умолчанию Posted
			    // tag: Id(PostTag)
			}
		  ```
	- `Notification`
		- неизменяемые вручную (изменяется только is_read и тот только в одну сторону)
		- создается только сервером
		- ```js
			{
				id: Id, // управляется сервером
				createdAt: IsoDateTime, // управляется сервером
				recipient: Id(User),
				title: str,
				content: str,
				is_read: bool, // управляется сервером, по умолчанию false
			}
		  ```
	- `ExpertApplication`
		- ```js
			{
				// 1й этап: создание
				id: Id, // управляется сервером
				status: ExpertApplicationStatus // управляется сервером
				createdBy: Id(User) // управляется сервером
				message: str,
				
				// 2й этап: отправка, поля не добавляются
				
				// 3й этап: взятие на рассмотрение, добавляются поля:
				acceptedBy: Id(User)?, // управляется сервером
				
				// 4й этап: решение по заявке, добавляются поля:
				isApproved: Bool?,
				resolutionMessage: str?,
			}
		  ```
		- Как это должно храниться
			- в бд:
				- Единая таблица с nullable полями, но с набором ограничений (constraints) для гарантии консистентности:
					- ```sql
						-- пример ограничения:
						Status <> 'AcceptedForReview' OR (
							acceptedBy IS NOT NULL AND
							isApproved IS NULL AND
							resolutionMessage IS NULL
						)
					```
			- на бэке
				- Несколько дтошек, по одной на каждый этап, каждая расширяет предыдущую своими полями (чтобы не приходилось каждый раз проверять поля на null)
			- на фронте
				- json с набором полей, соответствующих определенному этапу
				- набор полей можно понять по полю status
				- (полей со значением null быть не должно, пустые поля просто будут отсутствовать)
	- `ExpertApplicationAction
		- ```js
			{
				id: Id, // управляется сервером
				applicationId: Id(ExpertApplication), // управляется сервером
				datetime: IsoDateTime, // управляется сервером
				
				action: ExpertApplicationActionType, // управляется сервером
				other: JSONB? // управляется сервером
			}
		  ```


- /api/v0
	- /auth - логика связанная с авторизацией, представлена в виде контроллеров, а не ресурсов
		- /sendVerificationEmailForRegistration (POST) - отправляет на почту ссылку для регистрации
			- ссылка имеет следующий вид: `{url страницы с регистрацией}?token={access_token}`
			- токен будет с ролью `with_confirmed_email` и c почтой контексте
			- доступ:
				- для всех
			- тело:
				- `{email: str}`
			- ответы:
				- 204 - No Content
				- 422 - если почта не валидна
				- 409 - если почта уже занята
		- /register (POST) - создает пользователя с ролью `student`
			- доступ:
				- `with_confirmed_email`
			- тело:
				- username: str,<256 символов, разрешены латиница, цифры, подчеркивания
				- password: str
				- (email берется из токена, его передавать не нужно)
				- ==в будущем тут наверно должны быть личные данные==
			- ответы:
				- 201 - успешно создано
					- refresh токен кладется в куки
					- тело: `{ "access_token": "..." }`
				- 409 - если username уже занят
				- 422 - если пароль слишком слабый (силу можно проверять через `zxcvbn`)
		- /login (POST) - вход по паролю
			- доступ:
				- для всех
			- тело:
				- email: str
				- пароль: str
			- ответы:
				- 200 - ок
					- тело: `{ "access_token": "..." }`
					- refresh кладется в куки
				- 400
					- указана несуществующая почта
					- неверный пароль
				- 429
					- тут будет особо строгое ограничение по попыткам входа
		- /logout (POST) - выходит с устройства, деактивирует refresh и access токен
			- заголовки:
				- refresh токен (передается автоматически)
				- access токен нужен (даже если он устарел - не важно)
			- ответы:
				- 204 No Content
				- ошибок тут быть не может (даже если токены уже истекли, то все равно вернется 204, так просрочить токен это по сути то же самое, что выйти)
		- /refresh (POST) - обновляет refresh и access токены, отзывает старые
			- заголовки:
				- refresh передается автоматически, access не нужен
			- ответы:
				- 200 - ок
					- тело: `{ "access_token": "..." }`
					- refresh кладется в куки
				- 401 - если refresh токен истек
				- 429 - тут тоже более строгое ограничение
		- /changePassword (POST)
			- доступ: `logged_in`
			- тело: `{ old_password: ..., new_password: ... }`
			- ответы: 204/400/422 - если пароль слишком слабый
		- %% в будущем можно запрашивать подтверждение по почте для смены пароля %%
			- /sendVerificationEmailForResetPassword (POST) - отправляет на почту ссылку для сброса пароля
				- доступ: для всех
				- ссылка имеет вид `{url страницы для сброса пароля}?token={access_token}`
				- токен будет с ролью `with_confirmed_email` и c почтой контексте
				- тело:
					- `{email: str}`
				- Ответы: 204/400/404
		- /resetPassword (POST)
			- доступ:
				- `with_confirmed_email`
			- тело:
				- `{new_password: ...}`
			- ответы:
				- 204
				- 400, если тело в неверном формате
				- 401, если токен устарел или подделан
				- 422, если пароль слишком слабый (силу можно проверять через `zxcvbn`)
	
	- /users
		- /{id}/ (GET) - получает пользователя без персональных данных
			- доступ: для всех
			- ответы:
				- 200 ->`User`
				- 404 - нет такого
		- ?{параметры пагинации} (GET) - получение всех пользователей
			- можно использовать для получения всех админов: `?...&role=Admin`
			- доступ: `superadmin`
				- такой высокий, т.к. у нас пока никому кроме суперадминов просматривать всех пользователей не нужно
				- если станет нужно - ослабим ограничение
			- параметры:
				- `role:str?` - фильтрует по роли, если не указано - не фильтрует
			- ответы:
				- 200 ->`PaginationPage<User>`
				- 400/403
		- /{id} (PATCH) - редактирование полей (работает только на себя)
			- доступ: `logged_in`
			- тело: JSONPATCH над User без серверных полей
			- ответы:
				- 204/400/403/404
		- /{id}/anonymize (POST) - удаляет все данные пользователя, но сохраняет id в связанных ресурсах (работает только на себя)
			- доступ: `logged_in`
			- ответы: 204/403/404

	- %% /users/{id}/personalData  %%
		- / (GET) - возвращает персональные данные для лк (работает только на себя)
			- ответы:
				- 200 - ок
					- тело:
						- ```js
							{
								"id": "asdfasd-asdfasdf-asdfsdf",
								"fullName": "Иванов Иван Иваныч",
								"username": "IvanovIvan123",
								"role": "Expert", // из {Student, Expert, Admin}
								"birthDate": "1985-03-15",
								"address": "г. Москва, ул. Примерная, д. 10",
								"phone": "+79991234567",
								"avatarUrl": "https://example.com/static/avatar.jpg"
							}
						  ```
					  - birthDate, address, phone, avatarUrl - могут отсутствовать
				- 403/404

	- /users/{id}/roles/admin
		- / (PUT) - назначает пользователя админом
			- доступ: `superadmin`
			- ответы:
				- 204
				- 403 - нет роли
				- 404 - нет такого пользователя
				- 409 - уже админ
		- / (DELETE) - отозвать админку
			- доступ: `superadmin`
			- ответы:
				- 204
				- 403 - нет роли
				- 404 - нет такого пользователя
				- 409 - уже не админ

	- /courses
		- / (POST) - создает курс
			- доступ: `admin`
			- тело: типа `Course`, но без серверных полей
			- ответы:
				- 201 -> `Course`
				- 400 - ошибки в теле
				- 403 - нет роли
		- ?{параметры пагинации} (GET) - получить список курсов
			- доступ: для всех
			- ответы:
				- 200 - возвращает `PaginationPage<Course>`
				- 400 - при неверных параметрах
		- /{id} (GET) - получить курс
			- доступ: для всех
			- ответы:
				- 200 -> `Course`
				- 400 - ошибка в параметрах
				- 404 - нет такого
		- /{id} (PATCH) - редактирует курс
			- доступ: `admin`
			- тело: JSONPATCH над Course (не развернутом, без серверных полей)
			- ответы:
				- 204
				- 400 - ошибка параметров
				- 403 - нет роли
				- 404 - нет такого
		- /{id} (DELETE) - удаляет курс и отписывает всех пользователей от него
			- доступ: `admin`
			- тело, параметры: нет
			- ответы:
				- 204
				- 403 - нет роли
				- 404 - нет такого

	- /events
		- / (POST) - создает евент
			- доступ: `admin`
			- тело: `Event`, без серверных полей
			- ответы:
				- 201 -> `Event`
				- 400 - ошибки в теле
				- 403 - нет роли
		- ?{параметры пагинации} (GET) - получить список евентов
			- доступ: для всех
			- ответы:
				- 200 - возвращает `PaginationPage<Event>`
				- 400 - при неверных параметрах
		- /{id} (GET) - получить евент
			- доступ: для всех
			- ответы:
				- 200 - возвращает развенутый Course (у которого все Id bc)
				- 400 - ошибка в параметрах
				- 404 - нет такого
		- /{id} (PATCH) - редактирует евент
			- доступ: `admin`
			- тело: JSONPATCH над Event (не развернутом, без серверных полей)
			- ответы:
				- 204
				- 400 - ошибка параметров
				- 403 - нет роли
				- 404 - нет такого
		- /{id} (DELETE) - удаляет евент и отписывает всех пользователей от него
			- доступ: `admin`
			- тело, параметры: нет
			- ответы:
				- 204
				- 403 - нет роли
				- 404 - нет такого

	- /{coursesRegistrations/eventsRegistrations}
		- / (POST) - записывает пользователя на курс/евент
			- доступ: `student`
			- тело: `EventRegistration/CourseRegistration` без серверных полей
			- параметры: нет
			- ответы:
				- 201 -> `EventRegistration/CourseRegistration`
				- 400 - синтаксическая ошибка в теле
				- 403 - чужой айдишник
				- 404 - нет курса или пользователя
				- 409 - уже записан
		- ?{параметры пагинации}&userId={userId}&{courseId/eventId}={{courseId}/{eventId}} (GET)
			- доступ:
				- Если указан `userId`, то доступно только этому юзеру
				- Если `userId` не указан, то доступно только админам
			- параметры (кроме пагинации):
				- `userId: Id(User)?` - получение регистраций данного юзера
				- `courseId={courseId}` или `eventId={eventId}` - получений регистраций на данное мероприятие
				- указать оба эти параметра можно, хоть и не особо осмысленно - вернется регистрация данного пользователя на данное мероприятие (или ошибка, если он не зареган)
			- ответы:
				- 200 -> `PaginationPage<EventRegistration/CourseRegistration>`
				- 400 - ошибка формата в id/параметрах
				- 404 - нет такого курса
				- 422 - семантическая ошибка в параметрах
		- /{id} (GET) - получает запись
			- доступ: `student`, кому принадлежит эта запись
			- %% тело/параметры: нет %%
			- ответы:
				- 200 -> `EventRegistration/CourseRegistration`
				- 404 - ошибка формата id
				- 403 - нет роли или чужой ресурс
				- 404 - нет такой
		- /{id} (DELETE) - отменить запись
			- доступ: `student`, кому принадлежит эта запись
			- %% тело/параметры: нет %%
			- ответы:
				- 204
				- 404 - ошибка формата id
				- 403 - нет роли или чужой ресурс
				- 404 - нет такой

	- /posts
		- / (POST) - создание поста
			- доступ: `admin`
			- %% параметры: нет %%
			- тело: `Post` без серверных полей
				- status по умолчанию Posted
			- ответы:
				- 201 -> `Post`
				- 400 - в теле
				- 403 - нет роли
				- 422 - в теле
		- ?{параметры пагинации}&mine={isMine} (GET) - получение постов
			- доступ:
				- если mine=true: `admin`
				- иначе: для всех
			- %% тело: нет %%
			- параметры:
				- пагинация
				- expand
				- mine: `bool?`
					- если true - возвращает свои посты (в т.ч. скрытые)
					- по умолчанию - false
			- ответы:
				- 200 -> `PaginationPage<Post>`
				- 400 - в параметрах
				- 403 - нет доступа
				- 422 - в параметрах
		- /{id} (GET) - получение поста по id
			- доступ:
				- для публичных постов - для всех
				- для скрытых постов - `admin`, который автор поста
			- %% параметры/тело: нет %%
			- ответы:
				- 200 -> `Post`
				- 400 -> в id
				- 403 - пост скрытый и (ты не админ или не автор)
				- 404 (пост не найден)
		- /{id} (PATCH) - обновление поста
			- доступ: `admin`, автор поста
			- %% параметры: нет %%
			- тело: JSONPATCH над Post без серверных полей
			- ответы:
				- 200 -> Post
				- 400 - в id, теле
				- 403 - если не админ или не автор поста
				- 404 - нет такого поста
				- 422 - в теле
		- /{id} (DELETE) - удаление поста
			- доступ: `admin`, автор поста
			- %% параметры/тело: нет %%
			- ответы:
				- 204
				- 400 - в id
				- 403 - нет доступа
				- 404 - нет поста

	- /users/{id}/notifications
		- ?{параметры пагинации} (GET) - получить уведомления пользователя
			- доступ: `logged_in`, пользователь с данным id
			- %% тело: нет %%
			- параметры: пагинации
			- ответы:
				- 200 -> `PaginationPage<Notification>`
				- 400 - в id, теле
				- 403 - чужой пользователь
				- 404 - нету
				- 422 - в теле
		- /{id} (GET) - получить уведомление
			- доступ: `logged_in`, пользователь с данным id
			- %% тело: нет %%
			- %% параметры: нет %%
			- ответы:
				- 200 -> `Notification`
				- 400 - в id
				- 403 - чужой пользователь
				- 404 - нету
		- /{id}/markAsRead (PATCH) - пометить прочитанным
			- доступ: `logged_in`, пользователь с данным id
			- %% тело: нет %%
			- %% параметры: нет %%
			- ответы:
				- 204
				- 400 - в id
				- 403 - чужой пользователь
				- 404 - нету
				- 409 - уже прочитано

	- /expertApplications
		- про заявки
			- этапы обработки заявки можно представить как состояния стейт машины
				- схема
					- ![схема](https://i.ibb.co/svfDStbt/image.png)
			- перед вынесением решения по заявке ее нужно взять на рассмотрение
				- чтобы 2 админа одновременно не обрабатывали одну и ту же заявку
			- админ не может держать заявку на рассмотрении более чем N минут (N по умолчанию будет 60)
			- все действия с заявкой обратимые
				- чтобы дать возможность исправлять ошибки
			- все действия с заявкой сохраняются в истории
				- чтобы не было ситуации, когда пользователь пишет в поддержку "почему у меня вчера был статус эксперта, а сейчас его нет", а поддержка смотрит в базу, а там только текущее состояние и они ничего не могут ему ответить
			- у пользователя в лк отображается именно история
				- чтобы он понимал, что происходит с его заявкой
			- по дополнительным полям элементов истории вроде ни сортировать ни фильтровать не нужно, поэтому они в JSONB
		- / (POST) - создать заявку (и сохранить нужный экшон в истории)
			- доступ: `student`
			- тело: `ExpertApplication(Created)`, без серверных полей
			- ответы:
				- 201 -> `ExpertApplication(Created)`
				- 409 - уже есть заявка, по которой не вынесено решение или если уже эксперт
		- ?{параметры пагинации}&createdBy={...}&status={...}&acceptedBy={...} (GET) - получить заявки
			- доступ:
				- админ может смотреть только отправленные заявки, а пользователь только свои:
				- `admin` => `status` больше или равен `Sent`
				- `student` => должно быть указано `createdBy={id этого юзера}`
			- параметры:
				- пагинация
				- `createdBy: Id(User)?` - фильтрация по пользователю
					- чтобы пользователь смотрел свои заявки
				- `status: ExpertApplicationStatus?` - фильтрация по статусу
					- чтобы админ смотрел все отправленные заявки
				- `acceptedBy: Id(User)?` - фильтрация по взявшему
					- чтобы админ посмотрел, какие заявки он взял
			- ответы:
				- 201 -> `PaginationPage<ExpertApplication>`
		- /{id} (GET) - получить заявку
			- доступ: `student` - автор заявки или `admin`, если она была отправлена
			- ответы: 201 -> `ExpertApplication`
		- /{id} (PATCH) - редактировать заявку
			- доступ: `student` - автор заявки
			- тело:  JSONPATCH над `ExpertApplication` без серверных полей
			- ответы:
				- 200 -> `ExpertApplication`
				- 409 - если status выше или равен Accepted
		- /{id} (DELETE) - удалить заявку и ее историю
			- доступ: `student` - автор заявки
			- ответы:  204, 409 - если status выше или равен Accepted
	
		- /{id}/send (POST) - отправить (и сохранить нужный экшон в истории)
			- доступ: `student` (автор)
			- ответы: 204, 409 - если статус не Created
		- /{id}/cancelSending (POST) - отозвать заявку (и сохранить нужный экшон в истории)
			- доступ: `student` (автор)
			- ответы: 204, 409 - если статус не Sent
		- /{id}/accept (POST) - взять на рассмотрение (и сохранить нужный экшон в истории)
			- доступ: любой `admin`
			- %% на будущее: эффекты: заводит таймер на N минут, после которого произойдет /cancelAcceptance %%
			- ответы:
				- 200 -> `{bookedFor: int (minutes)}`
				- 409 - если статус не Sent
		- /{id}/cancelAcceptance (POST) - отменить рассмотрение (и сохранить нужный экшон в истории)
			- доступ: `admin`, который взял
			- ответы: 204, 409 - если статус не AcceptedForReview
		- /{id}/review (POST) - вынести решение по заявке (и сохранить нужный экшон в истории)
			- доступ:`admin`, который взял
			- эффекты
				- отправляет уведомление пользователю о том, что заявка рассмотрена
				- если заявка одобрена - делает пользователя экспертом
			- тело:
				- не серверные поля ExpertApplication, которые добавляются на этапе решения по заявке
			- ответы: 204, 409 - если статус не AcceptedForReview
		- /{id}/cancelReview (POST) - отменить решение по заявке (и сохранить нужный экшон в истории)
			- доступ: любой `admin`
			- эффекты:
				- отправляет уведомление о том, что решение по заявке отменено
				- снимает с пользователя статус эксперта, если он был
			- ответы: 204, 409 - если статус не Reviewed или если пользователь уже подал новую заявку (у одного пользователя не должно быть одновременно подано несколько не закрытых заявок т.к. возникают странные конфликтные ситуации)

	- /expertApplications/{id}/history (readonly ресурс)
		- ?{параметры пагинации} (GET) - посмотреть историю
			- доступ: выбранный `student`
			- ответы: 200 -> `PaginationPage<ExpertApplicationAction>

	- %% /{posts/events/couses}/categories   %%
		- ?{параметры пагинации} (GET) - список категорий
			- заголовки: нет, токен не нужен
			- ответы:
				- 200
					- тело:
						- ```js
							{
							    // обертка
								"items": [
							        {
							            "id": str,
							            "name": str,
							        },
							        ...
							    ]
							}
						  ```
				- 400
				- возможно 403 - дать смотреть только админам
		- (POST) - создание (админы)
			- тело: { "name": str }
			- ответы:
				- 201 {id:str, name:str}
				- 400
				- 403
				- 409 (если категория с таким именем уже есть)
		- /{id} (PATCH) - обновление (админы)
			- тело: в формате [JSONPATCH](http://jsonpatch.com/)
			- ответы:
				- 200
				- /400/403/404
		- /{id} (DELETE) - удаление (админы)
			- ответы:
				- 204
				- 404/403
	
	- %% /{posts/events/couses}/tags %%
		- все ровно то же самое, что и для категорий




